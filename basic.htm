<!DOCTYPE html>
<html>
<head>
	<title>Sim Monitor</title>
	<meta charset='utf-8'/>
</head>
<body>
<div statusbar>
	<img src='res/x.svg'/> <b var-date></b><b var-time></b><img src='res/bat.svg'/><img src='res/net.svg'/><img src='res/snd.svg'/>
</div>
<img wav src='res/wav.svg'/>
<canvas wav='hr' width='1000' height='200'></canvas>
<canvas wav='o2' width='1000' height='200'></canvas>
<div vital='HR'><input value='130'></input></div>
<div vital='SpO2'><input value='98'></input></div>
<div sub vital='RR'><input value='48'></input></div>
<div sub vital='NIBP'><input value='---/---'></input></div>
</body>

<script>
let l = console.log
let sinusRhythm = {
	amplitude: 1,
	cycle: {
		length: 100, // use JS to convert this to segment in canvas
		height: length*0.29
	},
	name: 'Sinus',
	pathCoordinates: [
		//StartPoints
		[0,0],
		//RelativeLineDrawing (Add x-px, Add y-px)
		[23,0],
	// Wave Peak #1
		[6,16],
		[6,-36],
	// Wave Peak #2
		[2, 120],
		[2, -140],
	// Wave balance
		[6,40],
		[9,0],
	// Wave peak #3
		[6, 20],
		[6, -20],
	// Wave Balance-end
		[34,0]
	]
}
let oxygenRhythm = {
	amplitude: 1,
	cycle: {
		length: 100,
		height: length*0.29
	},
	name: 'Oxygen',
	pathCoordinates: [
		//StartPoints
		[0,0],
		// PathCoordidates
		[23,0],
		[8,100],
		[3,0],
		[4,-20],
		[3,0],
		[4,-10],
		[6,-70],
		[6,0],
	]
}
let canvasHr = document.querySelector("[wav='hr']")
let canvasO2 = document.querySelector("[wav='o2']")

if (canvasHr.getContext) {
	var ctxHr = canvasHr.getContext('2d')
	ctxHr._containerWidth = canvasHr.offsetWidth
	ctxHr._containerHeight = canvasHr.offsetHeight
// TODO a- Remove need for numbers here and put idea into drawWave()
	setWaveformWidth(sinusRhythm, canvasHr.offsetWidth/5)

	var ctxO2 = canvasO2.getContext('2d')
	ctxO2._containerWidth = canvasO2.offsetWidth
	ctxO2._containerHeight = canvasO2.offsetHeight
	setWaveformWidth(oxygenRhythm, canvasHr.offsetWidth/5)

// TODO a- Let the waveform fill the whole container and let iterations fill up the whole container with cycles number
	waveformSinus(ctxHr)
	waveformOxygen(ctxO2)
}


/**
 * Draws a sinus HR waveform the the given context
 **/
function waveformSinus(context) {
	let c =context
	c.beginPath()
	c.lineCap = 'round'
	c.lineJoin = 'round'
	c.lineWidth = 2
	c.strokeStyle = 'lime'

	c.moveTo(0, 200) //x,y
	c.bezierCurveTo(10,10, 10,10, c._containerWidth,c._containerHeight) //ctrlPt1x, ctrlPt1y, cp2x, cp2y, x,y

	//c.arcTo(100,50, 200,50, 75) //x1,y1,x2,y2,radius
	//c.stroke()
	renderWave(c, sinusRhythm, 5)
}

/**
 * Draws an oxygen waveform to the given context
 **/
function waveformOxygen(context) {
	let c =context
	c.beginPath()
	c.lineCap = 'round'
	c.lineJoin = 'round'
	c.lineWidth = 2
	c.strokeStyle = 'cyan'
	renderWave(c, oxygenRhythm, 5)
}



/**
 * Adjusts waveform's total width to a given value
 **/
function setWaveformWidth(waveform, value) {
	let maxX= 0
	for (let i=0; i<waveform.pathCoordinates.length; i++) {
		maxX+= waveform.pathCoordinates[i][0]
	}
	waveform.cycle.length = (value/maxX)*100
}

/**
 * Renders the waveform to the context, repeated by the numberOfCycles.
 **/
function renderWave(context, waveform, numberOfCycles) {
	context.beginPath()
	let repeatPhaseBy = numberOfCycles
	waveform.pathCoordinates[0] = [0,context._containerHeight/2]
	for (let phaseNumber = 1; phaseNumber<=repeatPhaseBy; phaseNumber++) {
		//if (phaseNumber > 1) waveform.amplitude /=phaseNumber
		waveform.pathCoordinates[0] = drawWave(context, waveform)
	}
	context.stroke()
}

/**
 * Plots the coordinate points to the context from the waveform.
 * useExactCoordinates can be used to draw the coordinates as exact values instead of relative.
 * Returns the relative, non-exact, coordinates for usage with looping.
 **/
function drawWave(context, waveform, useExactCoordinates) {
	let c = context
	let coordinates = waveform.pathCoordinates
	let xy_prev = coordinates[0]
	let xy_last = xy_prev
  
	for (let xy_i in coordinates) {
		if (isNaN(xy_i) || xy_i == 0) continue

		let xy = coordinates[xy_i]
		let x = xy[0]
		let y = xy[1]*waveform.amplitude
		let newX = xy_prev[0]+x
		let newY = xy_prev[1]-y

		// Will interpret values as EXACT PIXEL locations to draw to and ignores assumed relative locations //
		if (useExactCoordinates) {
			newX = x
			newY = y
		}

		// Calculate the exact point location in canvas from relative (percent-based) drawing coordinates //
		let xper = (x, log)=> {
			let val = waveform.cycle.length*(x/100)
			if (log) l('x: '+x+' '+val)
			return val
		}
		let yper = (y, log)=> {
			let val = waveform.cycle.height*(y/100)
			if (log) l('y: '+y+' '+val)
			return y
		}

		// Placing the coordinates uses the exact values from the calculations //
		c.moveTo(
			xper(xy_prev[0], true), 
			yper(xy_prev[1], true)
		)
		c.lineTo(
			xper(newX), 
			yper(newY)
		)

		// Values stored do not use exact locations to ensure that waveform path data keeps consistent //
		xy_prev = [newX,newY]
		xy_last = [newX,newY]
	}
	return xy_last
}
</script>

<script>
let varDate = document.querySelector('[var-date]')
let varTime = document.querySelector('[var-time]')

setInterval(()=>{
	let now = new Date()
	let h = now.getHours(), m = now.getMinutes(), s = now.getSeconds()
	let mm = now.getMonth()+1, dd = now.getDate(), yy = now.getFullYear()

	if (h < 10) h = `0${h}`
	if (m < 10) m = `0${m}`
	if (s < 10) s = `0${s}`

	let date = `${mm}/${dd}/${yy}`
	let time = `${h}:${m}:${s}`
	varDate.innerHTML = date
	varTime.innerHTML = time
}, 1000)

let vitalsDivs = document.querySelectorAll('[vital]')
for (let divs_i in vitalsDivs) {
	if (isNaN(divs_i)) continue
	let div = vitalsDivs[divs_i]
	let b = document.createElement('b')
	let vitalType = div.getAttribute('vital')
	div.classList.add(vitalType.toLowerCase())
	b.innerHTML = vitalType
	b.onclick = ()=> {
		if (div.classList.contains('disabled') == false) {
			div.classList.add('disabled')
		}
		else {
			div.classList.remove('disabled')
		}
		let input = div.querySelector('input')
		if (input.value == '') {
			input.value = input.getAttribute('value-last')
			input.setAttribute('value-last', '')
		}
		else {
			input.setAttribute('value-last', input.value)
			input.value = ''
		}
	}
	div.appendChild(b)
}
</script>
<style>
* {
	background: none;
	margin: 0;
	padding: 0;
}
:root {
	--border-big: 0.2em;
	--border-small: 0.15em;
	--border-thick: 0.3em;
	--border-thin: 0.1em;
	--box-big: 18vw;
	--box-small: 8vw;
	--color-light: #eee;
}
html ,
input {
	background: none;
	border: none;
	color: var(--color-light);
}
html {
	/*background: #000;*/
	font-family: 'Sans', sans-serif;
}
body {
	padding: 2em 30%;
	position: relative;
}
canvas[wav] {
	background: black;
	border: solid 1px #88f;
	float: left;
	margin: 0;
	position: relative absolute;
}
.disabled b {
	text-decoration: line-through;
}
[statusbar] {
	display: flex;
	left: 0;
	position: fixed;
	top: 0;
	width: 100%;
}
[statusbar] * {
	flex-grow: 100%;
	font-size: 0.8em;
	height: 10%;
	margin: 0 5%;
	max-height: 2em;
}
[vital] {
	border: solid var(--border-big) var(--color-light);
	border-radius: 0.5rem;
}
[vital] {
	display: inline-block;
	float: right;
	height: var(--box-big);
	position: relative;
	vertical-align: top;
	width: var(--box-big);
}
[vital] b {
	left: 0;
	position: absolute;
	top: 0;
}
[vital] input {
	bottom: 0;
	font-size: 450%;
	font-weight: bold;
	height: 100%;
	position: relative absolute;
	right: 0;
	text-align: center;
	width: 100%;
}
[sub][vital] {
	height: var(--box-small);
	width: var(--box-small);
}
[sub][vital] input {
	font-size: 150%;
}
/*
[wav] {
	height: 4em;
	left: -1em;
	overflow: hide;
	position: absolute;
}
[wav] ~ * {
	margin-top: 6em;
}
*/
.hr,
.hr * {
	color: #4e4;
}
.spo2,
.spo2 * {
	color: #4ee;
}
.rr,
.rr * {
	color: #eee;
}
.nibp,
.nibp * {
	color: #e44;
}
</style>
</html>
